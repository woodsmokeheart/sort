let arr = [1, 4, 11, 12, 45, 198, 231, 99910, 1000000];

const mergeSort = function merge(arr, reverse = false) {
  // базовая ситуация; если массив меньше или равен 1 то возвращаем его назад
  if (arr.length <= 1) {
    return arr;
  }
  // Nеперь нужно разбить массив на две части  и запустить функцию
  // Метод slice() возвращает новый массив, содержащий копию части исходного массива.
  //   Обязательно сохраняем куски массива в переменной иначе нечему будет обрабатываться
  const left = merge(arr.slice(0, arr.length / 2), reverse); //левая  часть от начала и до середины
  const right = merge(arr.slice(arr.length / 2, arr.length), reverse); //правая  часть от середны  и до конца

  //   половины подготовлены теперь надо собрать новый отсортированный массив
  // теперь объявляем индексы
  let i = 0;
  let j = 0;

  //   теперь задаем новый массив в который мы будем все складывать. Изначально он пустой.
  const sorted_arr = [];

  //   теперь нужен цикл для обработки
  while (i < left.length && j < right.length) {
    if (left[i] === right[j]) {
      // если элемент из левой половины равено элементу из правой половины то мы кладем оба элемента в массив
      // Метод push() добавляет один или более элементов в конец массива и возвращает новую длину массива.
      sorted_arr.push(left[i], right[j]);
      //   после того как элементы положили оба счетчика увеличиваем
      i++;
      j++;
    } else if (!reverse ? left[i] < right[j] : left[i] > right[j]) {
      //если не реверс и если  левый элемент меньше чем правый элемент то кладем его в массив иначе  выполняем условие на укладывание в массив большего айтема и функция будет выводить массив в порядке убывания а не возрастания
      sorted_arr.push(left[i]);
      //   и увеличиваем счетчик на еденицу
      i++;
      //   при этом правый элемент не трогаем
    } else {
      // иначе делаем наоборот
      sorted_arr.push(right[j]);
      j++;
    }
  }

  //   после того как мы отсортировали массив и вышли из цикла то нам необходимо убедиться не остались ли в какой-то из половин элементы
  if (i !== left.length) {
    // если  ишки не равны длине левого массива то методом concat воозвращаем нащ массив sorted_arr в котором в конце добавлен остаток
    // Метод concat() возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.
    // при этом не забываем каждый раз делать возврат через return
    return sorted_arr.concat(left.slice(i, left.length));
  } else if (j !== right.length) {
    // если же j не равен длинне правой части то делаем то же самое и остаток правой части добавляем в массив
    return sorted_arr.concat(right.slice(j, right.length));
  }

  //   если же у нас сразу добавились все элементы через цикл то тогда просто возвращаем сортированный массив
  return sorted_arr;
};

console.log(mergeSort(arr, false));
